#!/usr/bin/env python
# Filename:      dirvish-stats
# Purpose:       helps determining used diskspace from hardlinked dirvish backups
# Authors:       (c) Michael Gebetsroither <gebi@grml.org>
# License:       This file is licensed under the GPL v2.
################################################################################

import os
import sys
import optparse
import inspect
import gdbm
from exceptions import *

CONFIG_=None

def die(msg, parser=None):
    sys.stderr.write("Error: "+msg+"\n")
    if parser:
        parser.print_help()
    sys.exit(1)

def warn(msg):
    sys.stderr.write("Error: "+msg+"\n")

def path_join(a, *p):
    '''pythons braindead os.path.join skips over all parts before an absolute path'''
    path = a
    for b in p:
        if b.startswith('/'):
            path += b
        else:
            path += '/' + b
    return path

def parse_index(fd):
    line_num = 0
    for i in fd:
        line_num += 1
        data = i.split(None,7)
        try:
            yield((data[0], data[2][:1], int(data[6]), i))   # (inode, type, size, line)
        except GeneratorExit:
            pass
        except Exception, e:
            braindead_find = False
            for type in ['c', 'b']:
                if data[2].startswith(type):
                    braindead_find = True
            if not braindead_find:
                import traceback
                traceback.print_exc()
                die("parsing %s:%d - \"%s\"" % (fd.name, line_num, " ".join(data)))

def config_human_sizes(size):
    if CONFIG_.human_readable:
        return human_sizes(size)
    else:
        return str(size)

def human_sizes(size):
    factor = 1024.
    times = 0
    times_format = ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y']
    ret = size
    while ret >= factor:
        ret = ret >> 10
        times += 1
        if ret < 10:
            return "%.1f%s" %(float(ret), times_format[times])
    return "%d%s" %(ret, times_format[times])

def print_stat(dir, size, size_new):
    print "%s: size %s, unshared %s" %(dir, config_human_sizes(size+size_new), config_human_sizes(size_new))

def print_new_files(dir, type, size, line):
    '''Used for output of stat -v'''
    hsize = config_human_sizes(size)
    name = line.split(None,10)[10]
    sys.stdout.write("%s %s" %(hsize, path_join(dir, 'tree', name)))

def multi_open(path):
    '''Trie to open a possible compressed file based on fileending'''
    def gzfile(filename):
        import gzip
        return gzip.GzipFile(filename)
    def bzfile(filename):
        import bz2
        return bz2.BZ2File(filename)
    opts = [(['.gzip','.gz'], gzfile),
            (['.bzip2', '.bz2'], bzfile),
            ([''], open)
           ]
    for (endings, fun) in opts:
        for ending in endings:
            file = path+ending
            if os.path.exists(file):
                return fun(file)
    raise RuntimeError('No index files found: %s' %os.path.abspath(path))

def open_dirvish_index(file_or_dir):
    '''Open possible compressed dirvish index file'''
    path = file_or_dir
    if os.path.islink(file_or_dir):
        realpath = os.path.realpath(file_or_dir)
        if os.path.isdir(realpath):
            path = realpath
    elif os.path.isdir(file_or_dir):
        path = path_join(file_or_dir, 'index')
    try:
        return multi_open(path)
    except RuntimeError, e:
        die(e.message)

def get_db_index_name(db_name):
    return db_name+'.i'

def read_db_index(db_name):
    s = set()
    for line in open(get_db_index_name(db_name),'r'):
        s.add(line.rstrip())
    return s

def write_db_index(db_name, db_set):
    fd = open(get_db_index_name(db_name),'w+')
    l = list(db_set)
    l.sort()
    for i in l:
        fd.write(i+'\n')
    fd.close()


# ACTIONS
def action_init(opts, args):
    '''init - Initialise db-FILE with given directories'''
    fd = open(get_db_index_name(opts.dbfile),'w+')
    fd.close()
    add_to_db(opts, args, 'nf')     # always create a _new_ db

def action_add(opts, args):
    '''add - Add directories to db-file'''
    add_to_db(opts, args, 'cf')     # open an existing db

def add_to_db(opts, args, db_flags):
    db = gdbm.open(opts.dbfile, db_flags)
    db_index = read_db_index(opts.dbfile)
    for dir in args:
        if dir in db_index:
            warn("%s already in db %s" %(dir, os.path.abspath(opts.dbfile)))
            continue
        db_index.add(dir)
        create_db(db, dir)
    write_db_index(opts.dbfile, db_index)
    db.close()

def create_db(db, dir):
    file = open_dirvish_index(dir)
    stat_size = 0
    stat_size_new = 0
    for (inode, type, size, line) in parse_index(file):
        if type == 'd':
            stat_size_new += size
            continue
        try:
            refcnt = int(db[inode])
            db[inode] = str(refcnt+1)
            if refcnt != 0:
                stat_size += size
            else:
                stat_size_new += size
        except:
            db[inode] = "1"
            stat_size_new += size
    print_stat(dir, stat_size, stat_size_new)

def action_rm(opts, args):
    '''rm - Remove directories from db-file'''
    db = gdbm.open(opts.dbfile, 'wf')
    db_index = read_db_index(opts.dbfile)
    for dir in args:
        if dir not in db_index:
            warn("%s not in db-index" %dir)
            continue
        db_index.remove(dir)
        remove_from_db(db, dir)
    write_db_index(opts.dbfile, db_index)
    db.close()

def remove_from_db(db, dir):
    file = open_dirvish_index(dir)
    stat_size = 0
    stat_size_new = 0
    for (inode, type, size, line) in parse_index(file):
        if type == 'd':
            stat_size_new += size
            continue
        try:
            refcnt = int(db[inode])
            if refcnt > 0:
                db[inode] = str(refcnt-1)
                if refcnt == 1:
                    stat_size_new += size
                else:
                    stat_size += size
            else:
                die("wrong or corrupted db (refcnt=%d;inode=%s): %s" %(refcnt, inode, os.path.abspath(opts.dbfile)))
        except KeyError:
            die("wrong or corrupted db (inode=%s): %s" %(inode, os.path.abspath(opts.dbfile)))
    print_stat(dir, stat_size, stat_size_new)

def action_stat(opts, args):
    '''stat - Print statistics of given directories using db-file'''
    db = gdbm.open(opts.dbfile, 'rf')
    db_index = read_db_index(opts.dbfile)
    for dir in args:
        if dir not in db_index:
            warn("%s not in db-index" %dir)
            continue
        create_stats(db, dir, opts.verbose)
    db.close()

def create_stats(db, dir, verbose=False):
    file = open_dirvish_index(dir)
    stat_size = 0
    stat_size_new = 0
    for (inode, type, size, line) in parse_index(file):
        if type == 'd':
            stat_size_new += size
            continue
        try:
            refcnt = db[inode]
            if refcnt == "1":
                stat_size_new += size
                if verbose:
                    print_new_files(dir, type, size, line)
                continue
            elif refcnt == "0":
                die("wrong or corrupted db (refcnt=0;inode=%s): %s" %(inode, os.path.abspath(opts.dbfile)))
            stat_size += size
        except KeyError:
            die("wrong or corrupted db (inode=%s): %s" %(inode, os.path.abspath(opts.dbfile)))
    print_stat(dir, stat_size, stat_size_new)

def action_dump(opts, args):
    '''dump - Dump human readable form of db-file (inode refcount)'''
    db = gdbm.open(opts.dbfile, 'rf')
    key = db.firstkey()
    while key != None:
        print "%s %s" %(key, db[key])
        key = db.nextkey(key)


# MAIN
if __name__ == "__main__":
    # actionname -> fun()
    actions = {}
    for k,v in globals().copy().iteritems():
        prefix = 'action_'
        if k.startswith(prefix):
            if callable(v):
                actions[k[len(prefix):]] = v
    docstrings = [ '\t'+inspect.getdoc(i) for i in actions.itervalues() ]
    docstrings.sort()
    usage = "usage: %prog [options] <action> [DIR/FILE] [DIR/FILE] ...\n\n" +\
            "%prog is a program which helps determining\n" +\
            "\tused diskspace from hardlinked dirvish backups\n\n" +\
            "ACTIONS:\n" + '\n'.join(docstrings)
    parser = optparse.OptionParser(usage, conflict_handler="resolve")
    parser.add_option("-f", "--dbfile", dest="dbfile", default="default.gdbm",
            metavar="FILE", help="Name of database file (%default)")
    #parser.add_option("-f", "--force", dest="force", action='store_true',
    #        default=False, help="Do as i say!")
    parser.add_option("-h", "--human-readable", dest="human_readable", action='store_true',
            default=False, help="Print sizes in human readable format")
    parser.add_option("-v", "--verbose", dest="verbose", action='store_true',
            default=False, help="Show more output")
    (opts, args) = parser.parse_args()
    CONFIG_ = opts
    if len(args) <1:
        die("no argument given", parser)
    cmd = args[0]
    if cmd == "help":
        parser.print_help()
        sys.exit(0)
    args = args[1:]
    if cmd in actions:
        actions[cmd](opts, args)
    else:
        parser.error("no such action: " + cmd)

