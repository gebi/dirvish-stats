#!/usr/bin/python

import os
import sys
import optparse
import inspect
import stat
import gdbm
from exceptions import *


def die(msg, parser=None):
    sys.stderr.write("Error: "+msg+"\n")
    if parser:
        parser.print_help()
    sys.exit(1)

def warn(msg):
    sys.stderr.write("Error: "+msg+"\n")

def path_join(a, *p):
    '''pythons braindead os.path.join skips over all parts before an absolute path'''
    path = a
    for b in p:
        if b.startswith('/'):
            path += b
        else:
            path += '/' + b
    return path

def parse_index(fd):
    line_num = 0
    for i in fd:
        line_num += 1
        data = i.split(None,7)
        try:
            yield((data[0], data[2][:1], int(data[6])))   # (inode, type, size)
        except:
            braindead_find = False
            for type in ['c', 'b']:
                if data[2].startswith(type):
                    braindead_find = True
            if not braindead_find:
                die("parsing %s:%d - \"%s\"" % (fd.name, line_num, " ".join(data)))


def human_sizes(size):
    factor = 1024.
    times = 0
    times_format = ['', 'K', 'M', 'G', 'T', 'P']
    ret = float(size)
    while ret > factor:
        ret /= factor
        times += 1
        if ret < 10:
            return "%.1f%s" %(ret, times_format[times])
    return "%d%s" %(int(ret), times_format[times])

def print_stat(dir, size, size_new):
    mb = 1048576
    print "%s: size %s, unshared %s" %(dir, human_sizes(size+size_new), human_sizes(size_new))

def multi_open(filename):
    '''Tries to open a possible compressed file based on fileending'''
    def gzfile(filename):
        import gzip
        return gzip.GzipFile(filename)
    def bzfile(filename):
        import bz2
        return bz2.BZ2File(filename)
    opts = [(['.gzip','.gz'], gzfile),
            (['.bzip2', '.bz2'], bzfile),
            ([''], open)
           ]
    for (endings, fun) in opts:
        for ending in endings:
            file = filename+ending
            if os.path.exists(file):
                return fun(file)

def get_db_index_name(db_name):
    return db_name+'.i'

def read_db_index(db_name):
    s = set()
    for line in open(get_db_index_name(db_name),'r'):
        s.add(line.rstrip())
    return s

def write_db_index(db_name, db_set):
    fd = open(get_db_index_name(db_name),'w+')
    for i in db_set:
        fd.write(i+'\n')
    fd.close()


# ACTIONS
def action_init(opts, args):
    '''init - initialise db-FILE of specified directories'''
    fd = open(get_db_index_name(opts.dbfile),'w+')
    fd.close()
    add_to_db(opts, args, 'nf')     # always create a _new_ db

def action_add(opts, args):
    '''add - add directory(s) to db-FILE'''
    add_to_db(opts, args, 'cf')     # open an existing db

def add_to_db(opts, args, db_flags):
    db = gdbm.open(opts.dbfile, db_flags)
    db_index = read_db_index(opts.dbfile)
    for dir in args:
        if dir in db_index:
            warn("%s already in db %s" %(dir, os.path.abspath(opts.dbfile)))
            continue
        db_index.add(dir)
        create_db(db, dir)
    write_db_index(opts.dbfile, db_index)
    db.close()

def create_db(db, dir):
    file = multi_open(path_join(dir, 'index'))
    stat_size = 0
    stat_size_new = 0
    for (inode, type, size) in parse_index(file):
        if type == 'd':
            stat_size_new += size
            continue
        try:
            refcnt = int(db[inode])
            if refcnt != 0:
                db[inode] = str(refcnt+1)
                stat_size += size
            else:
                stat_size_new += size
        except:
            db[inode] = "1"
            stat_size_new += size
    print_stat(dir, stat_size, stat_size_new)

def action_stat(opts, args):
    '''stat - print statistics of given directories using db-FILE'''
    db = gdbm.open(opts.dbfile, 'rf')
    db_index = read_db_index(opts.dbfile)
    for dir in args:
        if dir not in db_index:
            warn("%s not in db-index" %dir)
            continue
        create_stats(db, dir)
    db.close()

def create_stats(db, dir):
    file = multi_open(path_join(dir, 'index'))
    stat_size = 0
    stat_size_new = 0
    for (inode, type, size) in parse_index(file):
        if type == 'd':
            stat_size_new += size
            continue
        try:
            refcnt = db[inode]
            if refcnt == "1":
                stat_size_new += size
                continue
            elif refcnt == "0":
                die("wrong or corrupted db: "+os.path.abspath(opts.dbfile))
            stat_size += size
        except:
            die("wrong or corrupted db: "+os.path.abspath(opts.dbfile))
    print_stat(dir, stat_size, stat_size_new)


# MAIN
if __name__ == "__main__":
    # actionname -> fun()
    actions = {}
    for k,v in globals().copy().iteritems():
        prefix = 'action_'
        if k.startswith(prefix):
            if callable(v):
                actions[k[len(prefix):]] = v
    docstrings = [ '\t'+inspect.getdoc(i) for i in actions.itervalues() ]
    docstrings.sort()
    usage = "usage: %prog [options] <action> [DIR] [DIR] ...\n\n" +\
            "%prog is a program which helps determining\n" +\
            "\tused diskspace from hardlinked dirvish backups\n\n" +\
            "ACTIONS:\n" + '\n'.join(docstrings)
    parser = optparse.OptionParser(usage)
    parser.add_option("-d", "--dbfile", dest="dbfile", default="default.gdbm",
            metavar="FILE", help="Name of database file (%default)")
    parser.add_option("-f", "--force", dest="force", action='store_true',
            default=False, help="Do as i say!")
    (opts, args) = parser.parse_args()
    if len(args) <1:
        die("no argument given", parser)
    cmd = args[0]
    if cmd == "help":
        parser.print_help()
        sys.exit(0)
    args = args[1:]
    if cmd in actions:
        actions[cmd](opts, args)
    else:
        parser.error("no such action: " + cmd)

